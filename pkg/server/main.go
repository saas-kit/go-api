package server

import (
	"net/http"
	"os"
	"strings"

	"github.com/labstack/echo"
	"github.com/labstack/echo/middleware"
	eLog "github.com/labstack/gommon/log"
	"github.com/olekukonko/tablewriter"
	"golang.org/x/crypto/acme/autocert"
)

type (
	// Server structure
	// autoTLSMode enables automatically generation of a new LetsEncrypt certificate.
	// customCrtPath and customCrtKeyPath to add a custom TS certificate.
	// if autoTLSMode is enabled, custom ceritficates will be ignored.
	Server struct {
		router *echo.Echo
		config serverConfig
	}
)

// New func returns a new instance of the Server structure
func New(cnf serverConfig) *Server {
	router := echo.New()
	router.Debug = cnf.DebugMode()

	// Set default error handler
	router.HTTPErrorHandler = defaultHTTPErrorHandler

	// Set custom binder with automatic validation of a request structure
	router.Binder = &Binder{}

	// Will run before middlewares
	router.Pre(middleware.RemoveTrailingSlash())

	// Middleware
	router.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
		Format: "${time_rfc3339} [${status}] ${method}:${uri}, Latency: ${latency_human}\n",
	}))
	router.Logger.SetLevel(eLog.Lvl(cnf.LogLevel()))
	router.Use(middleware.Recover())
	router.Use(middleware.CORS())
	router.Use(middleware.SecureWithConfig(middleware.SecureConfig{
		Skipper:               middleware.DefaultSkipper,
		ContentSecurityPolicy: "default-src 'self'",
		ContentTypeNosniff:    "nosniff",
		HSTSMaxAge:            31536000, // 1 year
		XSSProtection:         "1; mode=block",
		XFrameOptions:         "DENY",
	}))
	router.Use(middleware.BodyLimit("2M"))
	router.Use(middleware.GzipWithConfig(middleware.GzipConfig{
		Level: cnf.GzipLevel(),
	}))

	if cnf.AutoTLSMode() {
		// TLS host policy
		router.AutoTLSManager.HostPolicy = autocert.HostWhitelist(cnf.APIDomain())
		// Cache certificates
		router.AutoTLSManager.Cache = autocert.DirCache(cnf.CrtDir())

		// Redirrect to non-www HTTPS URL
		router.Use(middleware.HTTPSNonWWWRedirect())
	} else {
		// Redirrect to non-www HTTP URL
		router.Use(middleware.NonWWWRedirect())
	}

	// Application health check endpoint
	router.GET("/health", healthCheckHandler)

	// Init server structure
	return &Server{
		router: router,
		config: cnf,
	}
}

// ListenAndServe function to handle requests on incoming connections via http
func (s *Server) ListenAndServe() error {
	// alias of the Server config property
	cnf := s.config

	// Print all registered routes
	s.printRoutes()

	// Start web server with autogenerated LetsEncrypt certificates
	if cnf.AutoTLSMode() {
		return s.router.StartAutoTLS(cnf.ListenPort())
	}

	// Start web server with custom TLS certificates
	if cnf.CustomCrtPath() != "" && cnf.CustomCrtKeyPath() != "" {
		return http.ListenAndServeTLS(cnf.ListenPort(), cnf.CustomCrtPath(), cnf.CustomCrtKeyPath(), s.router)
	}

	// Start simple web server
	return s.router.Start(cnf.ListenPort())
}

// Router returns the API router engine instance
func (s *Server) Router() *echo.Echo {
	return s.router
}

// PrintRoutes is a function to print registered routes
func (s *Server) printRoutes() {
	if !s.config.DebugMode() {
		return
	}

	methods := map[string]struct{}{
		echo.GET:    struct{}{},
		echo.POST:   struct{}{},
		echo.PUT:    struct{}{},
		echo.DELETE: struct{}{},
	}

	table := tablewriter.NewWriter(os.Stdout)
	table.SetHeader([]string{"Method", "Path", "Handler / Name"})
	table.SetAlignment(tablewriter.ALIGN_LEFT)
	for _, r := range s.router.Routes() {
		if _, ok := methods[r.Method]; ok && !strings.Contains(r.Name, "echo.(*Group).Use.func1") {
			table.Append([]string{r.Method, r.Path, r.Name})
		}
	}
	table.Render()
}
